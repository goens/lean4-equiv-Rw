import Tactic.replace_R

-- From: https://cs.ioc.ee/ewscs/2009/dybjer/mainPalmse-revised.pdf

inductive Exp (α : Type)
| app : Exp α → Exp α → Exp α
| id  : Exp α
| elem : α → Exp α


inductive R : (Exp α) → (Exp α) → Prop
| assoc {e e' e'' : Exp α} : R ((e.app e').app e'') (e.app (e'.app e''))
| id_left {e  : Exp α}     : R ((Exp.id).app e) (e)
| id_right {e : Exp α}     : R (e.app Exp.id) (e)
| refl     {e : Exp α}     : R (e) (e)
| symm      {e e' : Exp α}  : R (e) (e') → R (e') (e)
| trans {e e' e'' : Exp α} : R (e) (e') → R (e') (e'') → R (e) (e'')
| app {a b c d : Exp α}    : R (a) (b) → R (c) (d) → R (a.app c) (b.app d)


-- Setoid instance here:
instance R_Setoid : Setoid (Exp α) :=
  { r := R
    iseqv :=
      { refl := λ _ => R.refl
        symm := R.symm
        trans := R.trans
      }
  }

--User-given:
-- @[map₂]
def app_resp : ∀ ⦃a₁ a₂ : Exp α⦄, R a₁ a₂ → ∀ ⦃b₁ b₂ : Exp α⦄, R b₁ b₂ → R (a₁.app b₁) (a₂.app b₂)
  := fun ⦃a₁ a₂⦄ a ⦃b₁ b₂⦄ a_1 => R.app a a_1
-- Autogenerated from "@[map₂]" tag:
def app  {α}
  := @Quotient.map₂ (Exp α) (Exp α) (@R_Setoid α) (@R_Setoid α) (Exp α) (@R_Setoid α) (Exp.app) app_resp
def app_mk : {α : Type} → (x y : Exp α) → ⟦x.app y⟧ = @app α ⟦x⟧ ⟦y⟧
  := fun {α} x y => (@Quotient.map₂_mk (Exp α) (Exp α) (@R_Setoid α) (@R_Setoid α) (Exp α) (@R_Setoid α) (Exp.app) app_resp x y).symm


def eval : (Exp α) → (Exp α → Exp α)
  | Exp.app a b => (λ e => eval a (eval b e))
  | Exp.id      => id
  | Exp.elem x  => (λ e => (Exp.elem x).app e)


-- ∀ b, a.app b ~ [[a]]b
lemma eval_lemma1 (a : Exp α) : ∀ b, R (a.app b) ((eval a) b) :=
by
  induction a
  case app c d c_ih d_ih =>
    unfold eval
    intro b
    specialize d_ih b
    specialize c_ih (eval d b)
    -- Translate "R a b" to "⟦a⟧ = ⟦b⟧"
    have R.assoc := @R.assoc
    replace_R R R_Setoid
    simp only [app_mk] at *
    hide R.assoc
    -- (c ⬝ d) ⬝ b ~ c ⬝ (d ⬝ b) ~ c ⬝ (eval d b) ~ eval c (eval d b)
    -- "rewrite [R.assoc, d_ih, c_ih]"
    rw [R.assoc, d_ih, c_ih]

  case id =>
    intro b
    exact R.id_left

  case elem =>
    intro b
    exact R.refl

--User-given:
-- @[lift]
lemma eval_lemma2 (a b : Exp α) (h : R a b) : (eval a) = (eval b) :=
by
  apply funext
  induction h

  any_goals
    intros; aesop

  case app a b c d _ _ ab_ih cd_ih =>
    clear * - ab_ih cd_ih
    intro e
    specialize cd_ih e
    specialize ab_ih ((eval d) e)
    simp only [eval]
    rw [cd_ih, ab_ih]

-- Autogenerated from "@[lift]" tag:
def eval' {α}
  := @Quotient.lift (Exp α) (Exp α → Exp α) (@R_Setoid α) (eval) (eval_lemma2)
def eval'_mk {α} : (x : Exp α) → eval x = eval' ⟦x⟧
  := fun x => (@Quotient.lift_mk (Exp α) (Exp α → Exp α) (@R_Setoid α) (eval) (eval_lemma2) x).symm


def reify (f : Exp α → Exp α) : (Exp α) := f Exp.id

def nbe (e : Exp α) : Exp α := reify (eval e)

-- Shows decidability of e ~ e'
theorem correctness (e e' : Exp α) : (R (e) (e')) ↔ (nbe e = nbe e') :=
by
  apply Iff.intro
  · intro h
    induction h
    any_goals
      aesop
    case mp.app a b c d a_r_b c_r_d _ _ =>
      clear * - a_r_b c_r_d
      unfold nbe reify
      -- Translate "R a b" to "⟦a⟧ = ⟦b⟧"
      replace_R R R_Setoid
      simp only [app_mk, eval'_mk] at *

      grind

  · unfold nbe reify
    intro h0
    -- Translate "R a b" to "⟦a⟧ = ⟦b⟧"
    have R.id_right := @R.id_right
    have eval_lemma1:= @eval_lemma1
    replace_R R R_Setoid
    simp only [app_mk, eval'_mk] at *
    hide R.id_right
    hide eval_lemma1

    -- e ~ e ⬝ id ~ nbe e = nbe e' ~ e' ⬝ id ~ e'
    -- "rewrite [← R.id_right, eval_lemma1 e Exp.id, h0, ← eval_lemma1 e' Exp.id, R.id_right]"
    rw [← R.id_right, eval_lemma1 e Exp.id, h0, ← eval_lemma1 e' Exp.id, R.id_right]




-- Examples:

-- ((1, 2), ((0, 0), 3)) ~ ((0, 0), (1, (2, (0, 3))))
def zero := (Exp.id : Exp Nat)
def one  := Exp.elem 1
def two  := Exp.elem 2
def three := Exp.elem 3
example : R
          ( (one.app two).app  ((zero.app zero).app three) )
          ( (zero.app zero).app (one.app (two.app (zero.app three)))) :=
  by
  -- Translate "R a b" to "⟦a⟧ = ⟦b⟧"
  have R.id_left  := @R.id_left
  have R.assoc   := @R.assoc
  replace_R R R_Setoid
  simp only [app_mk] at *
  hide R.id_left
  hide R.assoc


  unfold zero
  simp only [R.id_left]

  --Minor hiccup here
  have eq : ∀ q, @app Nat ⟦Exp.id⟧ q = q := Quotient.ind (fun a => R.id_left)

  grind



-- ∀ x y, ((x, (0,0)), y) ~ (x, (y, (0,0)))
example : ∀ x y : Exp Nat, R ((x.app (zero.app zero)).app y) (x.app (y.app (zero.app zero))) :=
  by
  unfold zero
  -- Translate "R a b" to "⟦a⟧ = ⟦b⟧"
  have R.id_left' := @R.id_left
  have R.id_right':= @R.id_right
  have R.assoc'   := @R.assoc
  have R.app'     := @R.app
  replace_R R R_Setoid
  simp only [app_mk] at *
  hide R.id_left'
  hide R.id_right'
  hide R.assoc'
  hide R.app'

  grind


-- ∀ x y, ((x, (0,0)), y) ~ (x, (y, (0,0)))
example : ∀ x y : Exp ℕ, R ((x.app (zero.app zero)).app y) (x.app (y.app (zero.app zero))) :=
  by
  -- Translate "R a b" to "⟦a⟧ = ⟦b⟧"
  have R.id_right:= @R.id_right
  have R.app     := @R.app
  replace_R R R_Setoid
  hide R.id_right
  hide R.app

  intro x y
  conv_lhs =>
    apply R.app (R.app rfl ?_) rfl
    exact zero
    exact R.id_right
  conv_lhs =>
    apply R.app ?_ rfl
    exact x
    exact R.id_right
  conv_rhs =>
    apply R.app rfl (R.app rfl ?_)
    exact zero
    exact R.id_right
  conv_rhs =>
    apply R.app rfl ?_
    exact y
    exact R.id_right

-- ∀ x y, ((x, (0,0)), y) ~ (x, (y, (0,0)))
example : ∀ x y : Exp Nat, R ((x.app (zero.app zero)).app y) (x.app (y.app (zero.app zero))) :=
  by
  unfold zero
  have R.id_right:= @R.id_right

  -- Translate "R a b" to "⟦a⟧ = ⟦b⟧"
  replace_R R R_Setoid
  simp only [app_mk] at *

  aesop

-- ∀ x y, ((x, (0,0)), y) ~ (x, (y, (0,0)))
example {α β} : ∀ a b : Exp α, ∀ c d : Exp β,
  R ((a.app ((Exp.id).app (Exp.id))).app b) (a.app (b.app ((Exp.id).app (Exp.id))))
∧ R ((c.app ((Exp.id).app (Exp.id))).app d) (c.app (d.app ((Exp.id).app (Exp.id)))) :=
  by
  intro a b c d
  have R.id_right:= @R.id_right

  -- Translate "R a b" to "⟦a⟧ = ⟦b⟧"
  replace_R R R_Setoid
  simp only [app_mk] at *

  aesop
