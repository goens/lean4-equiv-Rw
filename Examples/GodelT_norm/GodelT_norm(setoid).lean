import Tactic.setoidRw

-- From: https://cs.ioc.ee/ewscs/2009/dybjer/mainPalmse-revised.pdf

inductive Ty : Type
| nat : Ty
| arrow : Ty → Ty → Ty
open Ty
infixr : 100 " ⇒' " => arrow

inductive Exp : Ty → Type
| K {a b : Ty}     :  Exp (a ⇒' b ⇒' a)
| S {a b c : Ty}   :  Exp ((a ⇒' b ⇒' c) ⇒' (a ⇒' b) ⇒' (a ⇒' c))
| app {a b : Ty}   :  Exp (a ⇒' b) → Exp a → Exp b
| zero             :  Exp nat
| succ             :  Exp (nat ⇒' nat)
| recN {a : Ty}    :  Exp (a ⇒' (nat ⇒' a ⇒' a) ⇒' nat ⇒' a)
open Exp
infixl : 100 " ⬝ " => app

-- Didn't declare Setoid instance yet
inductive R : Π {α : Ty}, (Exp α) → (Exp α) → Prop
| refl {α : Ty}{e : Exp α}
        : R (e) (e)
| symm   {α : Ty}{e e' : Exp α}
        : R (e) (e') → R (e') (e)
| trans {α : Ty}{e e' e'' : Exp α}
        : R (e) (e') → R (e') (e'') → R (e) (e'')
| K     {α β : Ty}{x : Exp α} {y : Exp β}
        : R (K ⬝ x ⬝ y) (x)
| S     {α β γ: Ty}{x : Exp (γ ⇒' β ⇒' α)} {y : Exp (γ ⇒' β)} {z : Exp γ}
        : R (S ⬝ x ⬝ y ⬝ z) (x ⬝ z ⬝ (y ⬝ z))
| app   {α β : Ty} {a b : Exp (β ⇒' α)} {c d : Exp β}
        : R (a) (b) → R (c) (d) → R (a ⬝ c) (b ⬝ d)
| recN_zero {α : Ty} {e : Exp α} {f : Exp (nat ⇒' α ⇒' α)}
        : R (recN ⬝ e ⬝ f ⬝ zero) (e)
| recN_succ {α : Ty} {n : Exp nat} {e : Exp α} {f : Exp (nat ⇒' α ⇒' α)}
        : R (recN ⬝ e ⬝ f ⬝ (succ ⬝ n)) (f ⬝ n ⬝ (recN ⬝ e ⬝ f ⬝ n))

-- Setoid instance here:
instance R_Setoid : Setoid (Exp α) :=
  { r := R
    iseqv :=
      { refl := λ _ => R.refl
        symm := R.symm
        trans := R.trans
      }
  }

--User-given:
--@[map₂]
def app_resp : ∀ ⦃a₁ a₂ : Exp (α ⇒' β)⦄, R a₁ a₂ → ∀ ⦃b₁ b₂ : Exp α⦄, R b₁ b₂ → R (a₁.app b₁) (a₂.app b₂)
  :=
  fun ⦃a₁ a₂⦄ a ⦃b₁ b₂⦄ a_1 => R.app a a_1
-- Autogenerated from "@[map₂]" tag:
def app' {α} {β}
  :=
  @Quotient.map₂ (Exp (α ⇒' β)) (Exp α) (@R_Setoid (α ⇒' β)) (@R_Setoid α) (Exp β) (@R_Setoid β) (Exp.app) (@app_resp α β)
def app'_mk : (x : Exp (α ⇒' β)) → (y : Exp α) → ⟦x.app y⟧ = app' ⟦x⟧ ⟦y⟧
  :=
  fun x y => (@Quotient.map₂_mk (Exp (α ⇒' β)) (Exp α) (@R_Setoid (α ⇒' β)) (@R_Setoid α)  (Exp β) (@R_Setoid β) (Exp.app) app_resp x y).symm


def Ty_inter : Ty → Type
| nat => ℕ

| arrow a b => Exp (a ⇒' b) × (Ty_inter a → Ty_inter b)



def numeral : ℕ → Exp nat
| 0 => zero

| n+1 => succ ⬝ (numeral n)


def reify (α : Ty) (e : Ty_inter α) : Exp α :=
  match α,e with
  | nat, e            => numeral e

  | arrow α β, (c, f) => c


def appsem {a b : Ty} (t : Ty_inter (a ⇒' b)) (e' : Ty_inter a) : Ty_inter b := (t.snd e')


def Exp_inter (a : Ty) : (e : Exp a) → Ty_inter a
| @K a b => (K,
            (λ p ↦ (K ⬝ (reify a p),
            (λ _ ↦ p))))
| @S a b c => (S,
              (λ x ↦ (S ⬝ (reify (a⇒'b⇒'c) x),
              (λ y ↦ (S ⬝ (reify (a⇒'b⇒'c) x) ⬝ (reify (a⇒'b) y),
              (λ z ↦ appsem (appsem x z) (appsem y z)))))))
| @app a b f e  => appsem (Exp_inter (a ⇒' b) f) (Exp_inter a e)
| zero          => (0 : ℕ)
| succ          => (succ,
                   (λ n : ℕ ↦ n+1) )
| @recN a       => (recN,
                   (λ p ↦ (recN ⬝ (reify a p),
                   (λ q ↦ (recN ⬝ (reify a p) ⬝ (reify (nat⇒'a⇒'a) q),
                   (λ n0 ↦ Nat.rec p (λ n r ↦ appsem (appsem q n) r) n0))))))


def nbe (a : Ty) (e : Exp a) : (Exp a) := reify a (Exp_inter a e)


-- e ~ e'  implies [[e]]a = [[e']]a
--User-given:
--@[lift]
lemma R_lemma1 : ∀ (e e' : Exp a), R e e' → ((Exp_inter a e) = (Exp_inter a e')) :=
by
  intro e e' h
  induction h
  any_goals aesop
  case app α β a b c d a_r_b c_r_d ab_ih cd_ih =>
    unfold Exp_inter
    rw [ab_ih, cd_ih]

-- Autogenerated from "@[map₂]" tag:
def Exp_inter' {α} := @Quotient.lift (Exp α) (Ty_inter α) (@R_Setoid α) (Exp_inter α) (@R_lemma1 α)

def Exp_inter'_mk  :  (x : Exp α) → Exp_inter α x = Exp_inter' ⟦x⟧
                  := fun x => (@Quotient.lift_mk (Exp α) (Ty_inter α) (@R_Setoid α) (Exp_inter α) (@R_lemma1 α) x).symm


-- e ~ e'  implies nbe a e = nbe a e'
--User-given:
--@[lift]
lemma soundness {a : Ty} {e e' : Exp a} : R e e' → nbe a e = nbe a e' :=
by
  unfold nbe
  intro h1

  translate R R_Setoid
  simp only [Exp_inter'_mk] at *

  grind

-- Autogenerated from "@[map₂]" tag:
def nbe' {α} := @Quotient.lift (Exp α) (Exp α) (@R_Setoid α) (nbe α) (@soundness α)

def nbe'_mk  :  (x : Exp α) → nbe α x = nbe' ⟦x⟧
                  := fun x => (@Quotient.lift_mk (Exp α) (Exp α) (@R_Setoid α) (nbe α) (@soundness α) x).symm


-- Tait-reducibility relation
def Red : (a : Ty) → (e : Exp a) → Prop
| nat, e       => R e (nbe nat e)

| arrow α β, e => R e (nbe (α ⇒' β) e)  ∧  ∀ e', Red α e' → Red β (app e e')

-- Red a e  implies  e ~ nbe a e
lemma Red_R_nbe (h : Red a e)  : R e (nbe a e) :=
  by
  cases a
  all_goals (unfold Red at h); aesop

-- e ~ e' implies  Red α e = Red α e'
-- User given:
--[@lift]
lemma Red_resp : ∀ e e', R e e' → (Red α e = Red α e')  :=
  by
  refine fun e e' a ↦ ?_ ; apply propext ; revert a e' e
  induction α
  · unfold Red
    intro a b a_r_b
    apply Iff.intro
    · intro a_r_nbe
      -- Translate "R a b" to "⟦a⟧ = ⟦b⟧":
      translate R R_Setoid
      simp only [nbe'_mk] at *
      -- b ~ a ~ nbe a = nbe b
      -- "rewrite [← a_r_b, a_r_nbe, soundness a_r_b]"
      grind
    · intro b_r_nbe
      -- Translate "R a b" to "⟦a⟧ = ⟦b⟧":
      translate R R_Setoid
      simp only [nbe'_mk] at *
      -- a ~ b ~ nbe b = nbe a
      -- "rewrite [a_r_b, b_r_nbe, ← soundness a_r_b]"
      grind

  · rename_i α β αIH βIH; clear αIH
    intros f1 f2 f1_r_f2
    apply Iff.intro
    · intro R_f1
      apply And.intro
      · have f1_r_nbe := Red_R_nbe R_f1; clear R_f1
        -- Translate "R a b" to "⟦a⟧ = ⟦b⟧":
        translate R R_Setoid
        simp only [nbe'_mk] at *
        -- f2 ~ f1 ~ nbe f1 = nbe f2
        -- "rewrite [← f1_r_f2, f1_r_nbe, soundness f1_r_f2]"
        grind
      · intro e' Re'
        rewrite [← βIH (f1 ⬝ e') (f2 ⬝ e') (f1_r_f2.app R.refl)]
        rcases R_f1 with ⟨_, h0⟩
        exact h0 e' Re'

    · intro R_f2
      apply And.intro
      · have f2_r_nbe := Red_R_nbe R_f2; clear R_f2
        -- Translate "R a b" to "⟦a⟧ = ⟦b⟧":
        translate R R_Setoid
        simp only [nbe'_mk] at *
        -- f1 ~ f2 ~ nbe f2 = nbe f1
        -- "rewrite [f1_r_f2, f2_r_nbe, ← soundness f1_r_f2]"
        grind
      · intro e' Re'
        translate R R_Setoid
        --simp only [app'_mk, Exp_inter'_mk, nbe'_mk] at *
        rewrite [βIH (f1 ⬝ e') (f2 ⬝ e') (by simp only [app'_mk] at * ; grind)]
        rcases R_f2 with ⟨left, h0⟩ ; clear left
        exact h0 e' Re'

--Auto-generated from [@lift]:
def Red' {α} := Quotient.lift (@Red α) (@Red_resp α)

def Red'_mk {α}
            : (x : Exp α) → Red α x = Red' ⟦x⟧
            := fun x => (Quotient.lift_mk (@Red α) (@Red_resp α) x).symm


lemma Red_numeral : Red nat (numeral n) :=
  by
  unfold Red
  induction n
  case zero => exact R.refl

  case succ n' IH =>
    unfold numeral
    have eq : nbe nat (succ ⬝ numeral n') = succ ⬝ (nbe nat $ numeral n') := rfl
    rewrite [eq] ; clear eq
    -- Translate "R a b" to "⟦a⟧ = ⟦b⟧":
    translate R R_Setoid
    simp only [app'_mk] at *
    -- succ ⬝ numeral n' ~ succ ⬝ nbe (numeral n')
    -- "rewrite [IH]"
    grind


-- for all e, Red a e
lemma all_Red {e : Exp a} : Red a e :=
  by
  induction e
  all_goals clear a
  case K a b =>
    apply And.intro
    · exact R.refl
    · intro e' Re'
      apply And.intro
      · have e'_r_nbe := Red_R_nbe Re'; clear Re'
        have eq : nbe (b ⇒' a) (K ⬝ e') = K ⬝ nbe a e' := rfl
        rewrite [eq] ; clear eq
        -- Translate "R a b" to "⟦a⟧ = ⟦b⟧"
        translate R R_Setoid
        simp only [app'_mk] at *
        -- K ⬝ e' ~ K ⬝ nbe e'
        -- "rewrite [e'_r_nbe]"
        grind

      · intro e'' Re''; clear Re''

        -- Translate "R a b" to "⟦a⟧ = ⟦b⟧"
        have R.K := @R.K
        translate R R_Setoid
        simp only [Red'_mk, app'_mk] at *
        hide R.K
        -- R (K ⬝ e' ⬝ e'') = R e'
        -- "rewrite [R.K]"
        rewrite [R.K]
        exact Re'

  case S a b c =>
    apply And.intro
    · exact R.refl
    · intro x Rx
      apply And.intro
      · have x_r_nbe := Red_R_nbe Rx; clear Rx
        have eq : nbe ((a ⇒' b) ⇒' a ⇒' c) (S ⬝ x) = S ⬝ nbe (a ⇒' b ⇒' c)  x := rfl
        rewrite [eq] ; clear eq
        -- Translate "R a b" to "⟦a⟧ = ⟦b⟧"
        translate R R_Setoid
        simp only [app'_mk] at *
        -- S ⬝ x ~ S ⬝ nbe x
        -- "rewrite [x_r_nbe]"
        rw [x_r_nbe]
      · intro y Ry
        apply And.intro
        · have x_r_nbe := Red_R_nbe Rx; clear Rx; have y_r_nbe := Red_R_nbe Ry; clear Ry
          have eq : nbe (a ⇒' c) (S ⬝ x ⬝ y) = S ⬝ nbe (a ⇒' b ⇒' c) x ⬝ nbe (a ⇒' b) y := rfl
          rewrite [eq] ; clear eq
          -- Translate "R a b" to "⟦a⟧ = ⟦b⟧"
          translate R R_Setoid
          simp only [app'_mk]
          -- S ⬝ x ⬝ y ~ S ⬝ nbe x ⬝ y ~ S ⬝ nbe x ⬝ nbe y
          -- "rewrite [x_r_nbe, y_r_nbe]"
          grind
        · intro z Rz
          rcases Rx with ⟨left, Rxz⟩; clear left; specialize Rxz z Rz
          rcases Ry with ⟨left, Ryz⟩; clear left; specialize Ryz z Rz
          rcases Rxz with ⟨left, Rxzyz⟩; clear left; specialize Rxzyz (y ⬝ z) Ryz

          -- Translate "R a b" to "⟦a⟧ = ⟦b⟧"
          have R.S := @R.S
          translate R R_Setoid
          simp only [Red'_mk, app'_mk] at *
          hide R.S
          -- "rewrite [R.S]"
          grind

  case app α β f x Rf Rx =>
    rcases Rf with ⟨_, h0⟩
    exact h0 x Rx

  case zero =>
    exact R.refl

  case succ =>
    apply And.intro
    · exact R.refl
    · intro x Rx
      unfold Red at *; rename' Rx => x_r_nbe
      have eq : nbe nat (succ ⬝ x) = succ ⬝ (nbe nat x) := rfl
      rewrite [eq] ; clear eq

      -- Translate "R a b" to "⟦a⟧ = ⟦b⟧"
      translate R R_Setoid
      simp only [app'_mk] at *
      -- succ ⬝ x ~ succ ⬝ nbe x
      -- "rewrite [x_r_nbe]"
      grind

  case recN α =>
    apply And.intro
    · exact R.refl
    · intro e' Re'
      apply And.intro
      · have e'_r_nbe := Red_R_nbe Re'; clear Re'
        have eq : nbe ((nat ⇒' α ⇒' α) ⇒' nat ⇒' α) (recN ⬝ e') = recN ⬝ nbe α e' := rfl
        rewrite [eq] ; clear eq
        -- Translate "R a b" to "⟦a⟧ = ⟦b⟧"
        translate R R_Setoid
        simp only [app'_mk] at *
        -- recN ⬝ e' ~ recN ⬝ nbe e'
        -- "rewrite [e'_r_nbe]"
        grind
      · intro e'' Re''
        apply And.intro
        · have e'_r_nbe := Red_R_nbe Re'; clear Re'; have e''_r_nbe := Red_R_nbe Re''; clear Re''
          have eq : nbe (nat ⇒' α) (recN ⬝ e' ⬝ e'') = recN ⬝ nbe α e' ⬝ nbe (nat ⇒' α ⇒' α) e'' := rfl
          rewrite [eq] ; clear eq

          translate R R_Setoid
          simp only [app'_mk] at *

          grind

        · intro n Rn
          have n_r_nbe := Rn; unfold R at n_r_nbe
          rewrite [Red_resp (recN ⬝ e' ⬝ e'' ⬝ n) (recN ⬝ e' ⬝ e'' ⬝ (nbe nat n)) (R.refl.app n_r_nbe)]
          unfold nbe; simp [reify]
          induction ((Exp_inter nat n))
          · unfold numeral

            have R.recN_zero := @R.recN_zero
            translate R R_Setoid
            simp only [Red'_mk, app'_mk] at *
            hide R.recN_zero
            -- "rewrite [R.recN_zero]"
            grind
          · rename_i n' IH
            unfold numeral
            have R_numeral_n' : Red nat (numeral n') := by exact Red_numeral
            rcases Re'' with ⟨left, h0⟩; clear left
            specialize h0 (numeral n') R_numeral_n'
            rcases h0 with ⟨left, h0⟩; clear left

            have R.recN_succ := @R.recN_succ
            translate R R_Setoid
            simp only [Red'_mk] at *
            hide R.recN_succ

            rewrite [R.recN_succ]
            aesop


-- e ~ nbe a e
lemma R_nbe {e : Exp a} : R e (nbe a e) := Red_R_nbe all_Red

-- nbe a e = nbe a e' implies e ~ e'
lemma completeness : nbe a e = nbe a e' → R e e' :=
  by
  intro eq
  -- Translate "R a b" to "⟦a⟧ = ⟦b⟧"
  have R_nbe := @R_nbe
  translate R R_Setoid
  hide R_nbe
  -- e ~ nbe e = nbe e' ~ e'
  -- "rewrite [R_nbe, eq, ← R_nbe]"
  rw [R_nbe, eq, ← R_nbe]

-- e ~ e' ↔ nbe a e = nbe a e'
lemma correctness {e e' : Exp a} : R e e' ↔ nbe a e = nbe a e' := ⟨soundness, completeness⟩



-- Examples:

example {α : Ty} {a b : Exp α}
                        (f : (x y : Exp α) → (@R α x y) → Nat)
                        (hf : (x y : Exp α) → (xRy : @R α x y) → f x y xRy = 3)
                        (aRb : R a b)
                        : (f a b aRb) = 3 :=
  by
  printEnv
  addR_eq `R `R_Setoid
  printEnv


  revert aRb hf f b a α
  generalize eq : @R = R'
  rewrite [R_eq] at eq
  subst eq
  beta_reduce
  intro α a b f hf aRb

  exact hf a b aRb


example : (α : Ty) → (a b c : Exp α) → (R a a) ∧ (R a b → R b a) ∧ (R a b → R b c → R a c) :=
  by
  /-
  intro α a b c
  repeat any_goals apply And.intro
  · exact R.refl
  · exact R.sym
  · exact R.trans
  -/
  translate R R_Setoid
  grind



example :
      (x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 : Exp nat)
      → (@R nat x1 x13)
      → (@R nat x10 x5)
      → (@R nat x4 x12)
      → (@R nat x7 x12)
      → (@R nat x14 x6)
      → (@R nat x14 x9)
      → (@R nat x12 x12)
      → (@R nat x12 x17)
      → (@R nat x20 x3)
      → (@R nat x7 x1)
      → (@R nat x3 x14)
      → (@R nat x9 x18)
      → (@R nat x19 x14)
      → (@R nat x12 x6)
      → (@R nat x10 x4)
      → (@R nat x6 x8)
      → (@R nat x16 x9)
      → (@R nat x6 x17)
  := by
    translate R R_Setoid
    grind

example :
      (x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 : Exp nat)
      → (@R nat x12 x4)
      → (@R nat x5 x1)
      → (@R nat x6 x9)
      → (@R nat x17 x7)
      → (@R nat x1 x9)
      → (@R nat x4 x17)
      → (@R nat x17 x12)
  := by
    translate R R_Setoid
    grind

example : ∀ x y : Exp (nat ⇒' nat), R (x.app (x.app (x.app zero))) (x.app (y.app (x.app zero))) :=
  by
  translate R R_Setoid
  simp only [app'_mk] at *
  sorry
